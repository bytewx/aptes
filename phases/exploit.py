#!/usr/bin/env python3
"""
Exploitation phase module for APTES
"""

import logging
from datetime import datetime
import os

from phases.base import PhaseBase
from lib.tools import run_sqlmap_advanced

class ExploitationPhase(PhaseBase):
    """Exploitation Phase Controller"""

    def __init__(self, framework):
        """Initialize the Exploitation phase controller"""
        super().__init__(framework)
        self.framework = framework
        self.recon_results = framework.results.get("recon", {})
        self.preexploit_results = framework.results.get("preexploit", {})
        self.results = {
            "exploitation_summary": {
                "attempts": 0,
                "successful": 0,
                "failed": 0
            },
            "exploits": [],
            "shells": [],
            "privilege_escalation": [],
            "llm_suggestions": None,
            "sqlmap_advanced": None
        }

    def _execute(self, auto_exploit=False, exploit_filter=None):
        """
        Execute exploitation phase operations, including LLM suggestions.
        Args:
            auto_exploit (bool): Automatically exploit without confirmation
            exploit_filter (dict): Filter for vulnerabilities to exploit
        Returns:
            dict: Exploitation results
        """
        self.logger.info(f"Starting exploitation phase for {self.target}")

        # Get attack vectors from preexploit phase
        attack_vectors = []
        if "attack_vectors" in self.preexploit_results:
            attack_vectors = self.preexploit_results["attack_vectors"]

        # Apply filter if provided
        if exploit_filter and "risk_level" in exploit_filter and attack_vectors:
            attack_vectors = [v for v in attack_vectors if v.get("risk_level") in exploit_filter["risk_level"]]

        # Log exploitable vulnerabilities
        self.results["exploitation_summary"]["attempts"] = len(attack_vectors)
        self.results["exploitation_summary"]["successful"] = 0
        self.results["exploitation_summary"]["failed"] = len(attack_vectors)

        for vector in attack_vectors:
            self.results["exploits"].append({
                "name": vector.get("name", "Unknown"),
                "target": vector.get("target", self.target),
                "type": vector.get("type", "Unknown"),
                "risk_level": vector.get("risk_level", "Unknown"),
                "success": False,
                "details": "Exploitation not implemented in this version"
            })

        # LLM suggestions via OpenAI router
        context = {
            "target": self.target,
            "recon": self.recon_results,
            "preexploit": self.preexploit_results
        }
        llm_response = self._query_llm_for_exploit(context)
        self.results["llm_suggestions"] = llm_response

        # Optionally run advanced SQLMap
        sqlmap_results = run_sqlmap_advanced(
            target=self.framework.target,
            output_dir=self.framework.output_dir,
            crawl_depth=5,
            flush_session=True
        )
        self.results["sqlmap_advanced"] = sqlmap_results

        self.logger.info(f"Exploitation phase completed for {self.target}")

        # Generate HTML, Excel, and Markdown combined reports after all steps
        try:
            from utils.reporting import ReportGenerator
            reporter = ReportGenerator(
                results=self.framework.results,
                target=self.target,
                output_dir=self.framework.output_dir
            )
            # Use a consistent base filename for all combined reports
            today = datetime.now().strftime("%Y%m%d")
            target_safe = self.target.replace(".", "_").replace(":", "_").replace("/", "_")
            base_filename = f"{self.framework.output_dir}/{target_safe}_recon_preexploit_exploit_{today}"

            # JSON (already handled elsewhere, but ensure it's done)
            import json
            with open(f"{base_filename}.json", "w", encoding="utf-8") as f:
                json.dump(self.framework.results, f, indent=2, ensure_ascii=False)

            # HTML
            reporter.generate_combined_html_report(filename=f"{base_filename}.html")
            # Excel
            if hasattr(reporter, "generate_combined_reports"):
                # If new API is present, use it (for future-proofing)
                reporter.generate_combined_reports(filename_base=base_filename)
            else:
                # Fallback: try to generate Excel manually
                if hasattr(reporter, "_generate_combined_excel_report"):
                    reporter._generate_combined_excel_report(f"{base_filename}.xlsx")
            self.logger.info(f"Combined reports (json/html/excel) saved to {base_filename}.*")

        except Exception as e:
            self.logger.error(f"Error generating combined reports: {str(e)}")

        return self.results

    def _query_llm_for_exploit(self, context):
        """
        Query OpenAI router for exploitation suggestions, sending recon and preexploit in separate messages.
        Args:
            context (dict): Recon and preexploit data.
        Returns:
            dict: LLM response with exploitation steps.
        """
        try:
            from openai import OpenAI
            client = OpenAI(
                base_url="https://openrouter.ai/api/v1",
                api_key="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"
            )
        except ImportError:
            self.logger.error("openai package not installed")
            return {"error": "openai package not installed"}

        import json
        import os
        from datetime import datetime

        # Load recon and preexploit results as JSON strings
        recon_data = context.get("recon", {})
        preexploit_data = context.get("preexploit", {})

        # If empty, try to load from report file
        if not recon_data or not preexploit_data:
            today = datetime.now().strftime("%Y%m%d")
            safe_target = self.target.replace(".", "_").replace(":", "_").replace("/", "_")
            report_filename = f"{safe_target}_recon_{today}.json"
            report_path = os.path.join(
                os.path.dirname(os.path.dirname(__file__)), "reports", report_filename
            )
            if os.path.exists(report_path):
                try:
                    with open(report_path, "r", encoding="utf-8") as f:
                        report_data = json.load(f)
                    if not recon_data and "recon" in report_data:
                        recon_data = report_data["recon"]
                    if not preexploit_data and "preexploit" in report_data:
                        preexploit_data = report_data["preexploit"]
                except Exception as e:
                    self.logger.error(f"Failed to load report file {report_path}: {e}")
        
        recon_str = report_data
        
        if not recon_data or not preexploit_data:
            today = datetime.now().strftime("%Y%m%d")
            safe_target = self.target.replace(".", "_").replace(":", "_").replace("/", "_")
            report_filename = f"{safe_target}_preexploit_{today}.json"
            report_path = os.path.join(
                os.path.dirname(os.path.dirname(__file__)), "reports", report_filename
            )
            if os.path.exists(report_path):
                try:
                    with open(report_path, "r", encoding="utf-8") as f:
                        report_data = json.load(f)
                    if not recon_data and "recon" in report_data:
                        recon_data = report_data["recon"]
                    if not preexploit_data and "preexploit" in report_data:
                        preexploit_data = report_data["preexploit"]
                except Exception as e:
                    self.logger.error(f"Failed to load report file {report_path}: {e}")

        preexploit_str = report_data

        # Compose message history: system, recon, preexploit, then user prompt
        messages = [
            {
                "role": "system",
                "content": (
                    "You are an expert red team operator leader. "
                    "You know everything about ethical hacking and you are thinking outside of the box, "
                    "and you are allowed to use any tool."
                )
            },
            {
                "role": "user",
                "content": (
                    "Here are the reconnaissance phase results for the target:\n"
                    f"{recon_str}\n"
                )
            },
            {
                "role": "user",
                "content": (
                    "Here are the pre-exploitation phase results for the target:\n"
                    f"{preexploit_str}\n"
                )
            },
            {
                "role": "user",
                "content": (
                    "Given the above reconnaissance and pre-exploitation results, "
                    "suggest concrete exploitation steps for the target. "
                    "Be specific and actionable and write verbosely. Respond with a list of steps and a rationale for each."
                )
            }
        ]

        try:
            response = client.chat.completions.create(
                model="meta-llama/llama-4-scout:free",
                messages=messages,
            )
            content = response.choices[0].message.content
            try:
                return json.loads(content)
            except Exception:
                return {"raw_response": content}
        except Exception as e:
            self.logger.error(f"LLM request failed: {e}")
            return {"error": str(e)}

    def run(self, auto_exploit=False, exploit_filter=None, **kwargs):
        """
        Run exploitation phase operations with additional tools.
        Args:
            auto_exploit (bool): Automatically exploit without confirmation
            exploit_filter (dict): Filter for vulnerabilities to exploit
            kwargs: Additional arguments for exploitation tools
        Returns:
            dict: Exploitation results
        """
        return self._execute(auto_exploit=auto_exploit, exploit_filter=exploit_filter)
